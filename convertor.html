<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>HDFC TXT → CSV (paise + verify)</title>
<style>
  body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial; padding:18px; max-width:1100px; margin:auto}
  textarea{width:100%;height:320px;font-family:monospace;font-size:13px}
  .row{display:flex;gap:8px;align-items:center;margin:8px 0}
  button{padding:8px 12px}
  .info{color:#666;font-size:13px}
  pre{background:#f6f8fa;padding:12px;overflow:auto;max-height:360px}
  label{font-size:14px}
  .controls{display:flex;gap:12px;flex-wrap:wrap;align-items:center;margin-bottom:10px}
  .small{font-size:13px;color:#444}
  table{border-collapse:collapse;width:100%;font-size:13px}
  td,th{border:1px solid #ddd;padding:6px}
  .ok{color:green}
  .bad{color:crimson}
</style>
</head>
<body>
  <h2>HDFC TXT → CSV converter (paise integers + verify)</h2>
  <p class="info">Paste the statement text or upload the extracted .txt. Options: write paise integers, output NULL for non-used side, and run Verify (simulation of balances).</p>

  <div class="row">
    <input id="file" type="file" accept=".txt,text/plain" />
    <button id="loadSample">Load small sample</button>
  </div>

  <textarea id="inputText" placeholder="Paste your .txt statement here..."></textarea>

  <div class="controls">
    <label><input id="optPaise" type="checkbox" checked /> Produce paise integer fields (amount_paise, debit_paise, credit_paise, balance_paise)</label>
    <label><input id="optNullSide" type="checkbox" /> Output non-used side as literal <code>NULL</code> (instead of 0)</label>
    <label><input id="optVerify" type="checkbox" /> Run verify simulation after parse</label>
    <button id="convert">Convert & Download CSV</button>
    <button id="runVerify">Run Verify Now</button>
    <a id="downloadLink" style="display:none;margin-left:8px">Download CSV</a>
    <a id="downloadReport" style="display:none;margin-left:8px">Download Verify Report (JSON)</a>
    <span id="status" class="info"></span>
  </div>

  <h4>Preview (first 10 rows)</h4>
  <pre id="preview" class="small"></pre>

  <h4>Verify Report</h4>
  <pre id="verifyReport" class="small">(run verify or use "Convert" with Verify option)</pre>

<script>
/*
  Full parser + CSV generator with:
    - paise integer fields
    - option to output NULL for the non-used side
    - verify run simulation using balance-diff algorithm

  Output CSV headers:
    txn_date,value_date,counterparty,narration,reference,txn_type,amount_paise,debit_paise,credit_paise,balance_paise,raw_line

  Numeric paise fields are emitted without quotes. String fields are quoted only if necessary.
*/

/* ---------- Parsing function (returns rows with integer paise fields) ---------- */
function parseStatementToRows(text) {
  const safeTrim = s => (s||'').toString().replace(/\r/g,'').trim();
  const dateStartRe = /^\s*(\d{1,2}[\/-]\d{1,2}[\/-]\d{2,4})\b/;
  const moneyRegexGlobal = /\d{1,3}(?:,\d{3})*(?:\.\d{1,2})?/g;

  function parseMoneyToPaise(str) {
    if (str === null || str === undefined) return null;
    const m = (''+str).match(/\d{1,3}(?:,\d{3})*(?:\.\d{1,2})?/);
    if (!m) return null;
    const cleaned = m[0].replace(/,/g,'');
    const val = parseFloat(cleaned);
    if (!isFinite(val)) return null;
    return Math.round(val * 100);
  }
  function paiseToRupees(p) {
    if (p === null || p === undefined || p === '') return '';
    const n = Number(p);
    if (!isFinite(n)) return '';
    return (n/100).toFixed(2);
  }
function extractCounterparty(narr) {
  if (!narr) {
    console.error('extractCounterparty: narration is empty or undefined');
    return '';
  }
  try {
    // Remove UPI/IMPS/NEFT/RTGS prefixes and split by dash
    let n = narr.replace(/^(UPI|IMPS|NEFT|RTGS|REV|POS|NWD|ATM|FEE|INT|CR|DR)[\-\s]*/i, '');
    // Take the first dash-separated part before any @ or number sequence
    let dashParts = n.split('-').map(s => s.trim()).filter(Boolean);
    let candidate = '';
    for (let part of dashParts) {
      // If part contains @ or is mostly numbers, skip
      if (/@/.test(part) || /\d{4,}/.test(part)) continue;
      // If part is not a known keyword and has at least two words, use it
      if (!/upi|imps|neft|rtgs|bank|online|payment|transfer|fee|int|cr|dr|atm|pos|nwd|rev/i.test(part) && /\s/.test(part)) {
        candidate = part;
        break;
      }
    }
    if (!candidate && dashParts.length > 0) {
      // fallback: use first part with letters
      candidate = dashParts.find(p => /[a-zA-Z]/.test(p)) || '';
    }
    // Capitalize
    candidate = candidate.toLowerCase().replace(/\b\w/g, ch => ch.toUpperCase());
    if (!candidate) {
      console.error('extractCounterparty: could not extract counterparty from narration:', narr);
    }
    return candidate.trim();
  } catch (err) {
    console.error('extractCounterparty: error parsing narration:', narr, err);
    return '';
  }
}



  const lines = text.split(/\r?\n/);

  // extract Opening Balance if available (first found token)
  let openingBalancePaise = null;
  for (let i=0;i<lines.length;i++) {
    const ln = lines[i];
    // example: "Opening Balance                                                      Debits  ..."
    const m = ln.match(/Opening\s*Balance[^\d\-]*([\d,]+(?:\.\d{1,2})?)/i);
    if (m && m[1]) {
      openingBalancePaise = parseMoneyToPaise(m[1]);
      break;
    }
  }

  // header detection
  let headerLine = null;
  for (let i=0;i<lines.length;i++){
    const ln = lines[i];
    if (/Date\b.*Value\s*Dt\b.*Withdrawal\b.*Deposit\b.*Closing\s*Balance/i.test(ln)) {
      headerLine = ln;
      break;
    }
  }

  const rows = [];
  let previousBalancePaise = openingBalancePaise !== null ? openingBalancePaise : null;

  // helper that builds a row object (paise ints)
  function buildRow(txnDate, valueDate, narration, ref, counterparty, txn_type, amountPaise, closingPaise, raw) {
    const debit_pa = (txn_type === 'debit') ? (amountPaise || 0) : 0;
    const credit_pa = (txn_type === 'credit') ? (amountPaise || 0) : 0;
    return {
      txn_date: txnDate || '',
      value_date: valueDate || '',
      counterparty: counterparty || '',
      narration: (narration||'').replace(/\s+/g,' ').trim(),
      reference: (ref||'').trim(),
      txn_type: txn_type || 'other',
      amount_paise: amountPaise !== null ? (amountPaise || 0) : 0,
      debit_paise: debit_pa,
      credit_paise: credit_pa,
      balance_paise: closingPaise !== null ? closingPaise : null,
      raw_line: raw || ''
    };
  }

  if (headerLine) {
    // header-aware: we still rely on money tokens (first = amount candidate, last = closing)
    for (let i=0;i<lines.length;i++){
      const raw = lines[i];
      const trimmed = safeTrim(raw);
      if (!trimmed) continue;
      if (/hdfc bank ltd|page no\.|statement of accounts|statement from|statement summary|opening balance|dr count|cr count|\*\*continue\*\*/i.test(trimmed)) continue;
      if (!dateStartRe.test(raw)) continue;

      // collect money tokens
      let moneyMatches = [];
      let mm;
      while ((mm = moneyRegexGlobal.exec(raw)) !== null) moneyMatches.push({text:mm[0], idx:mm.index});
      if (moneyMatches.length === 0) continue;

      const firstMoneyText = moneyMatches[0].text;
      const lastMoneyText = moneyMatches[moneyMatches.length - 1].text;
      const amountCandidatePaise = parseMoneyToPaise(firstMoneyText);
      const closingPaise = parseMoneyToPaise(lastMoneyText);

      // capture dates (first two date tokens)
      const dateMatches = Array.from(raw.matchAll(/\d{1,2}\/\d{1,2}\/\d{2,4}/g)).map(x=> ({text:x[0], idx:x.index}));
      const dateRaw = dateMatches[0] ? dateMatches[0].text : '';
      const valDateRaw = dateMatches[1] ? dateMatches[1].text : '';

      // approximate narration/ref slice: between first date and value date or between date and first money token
      let narration = '', refField = '';
      if (dateRaw && valDateRaw) {
      const start = raw.indexOf(dateRaw) + dateRaw.length;
      // find the second occurrence of valDateRaw (search from 'start'); fallback to first occurrence or end-of-line
      let end = -1;
      if (valDateRaw) {
        end = raw.indexOf(valDateRaw, start);        // look for the next occurrence after the first date
        if (end === -1) end = raw.indexOf(valDateRaw); // fallback: any occurrence
      }
      if (end === -1) end = raw.length;
      const mid = (end > start) ? raw.slice(start, end).trim() : '';

        const parts = mid.split(/\s{2,}/).map(s=>s.trim()).filter(Boolean);
        narration = parts[0] || '';
        refField = parts.slice(1).join(' ') || '';
      } else {
        const firstMoneyIdx = moneyMatches[0].idx;
        const dateIdx = raw.search(/\d{1,2}\/\d{1,2}\/\d{2,4}/);
        if (dateIdx >= 0 && firstMoneyIdx > dateIdx) {
          const mid = raw.slice(dateIdx + (dateRaw?dateRaw.length:0), firstMoneyIdx).trim();
          const parts = mid.split(/\s{2,}/).map(s=>s.trim()).filter(Boolean);
          narration = parts[0] || '';
          refField = parts.slice(1).join(' ') || '';
        } else {
          // fallback whole pre-last-money part
          const beforeLastMoney = raw.slice(0, moneyMatches[moneyMatches.length-1].idx).trim();
          narration = beforeLastMoney;
        }
      }

      // normalize txn date
      let txnDate = '';
      if (dateRaw) {
        const d = dateRaw.match(/(\d{1,2})\/(\d{1,2})\/(\d{2,4})/);
        if (d) {
          let dd = d[1].padStart(2,'0'), mmn = d[2].padStart(2,'0'), yy = d[3];
          if (yy.length===2) yy = '20' + yy;
          txnDate = `${yy}-${mmn}-${dd}`;
        }
      }

      // Balance diff logic:
      // If previousBalance is known and both amountCandidate & closingPaise are known, check both:
      // previous + amount == closing => credit
      // previous - amount == closing => debit
      let determinedType = null;
      let finalAmountPaise = amountCandidatePaise !== null ? amountCandidatePaise : 0;
      if (previousBalancePaise !== null && finalAmountPaise !== null && closingPaise !== null) {
        if (previousBalancePaise + finalAmountPaise === closingPaise) determinedType = 'credit';
        else if (previousBalancePaise - finalAmountPaise === closingPaise) determinedType = 'debit';
      }

      // fallback heuristics
      if (!determinedType) {
        // if there is a mid-money token before the last, try that as actual txn amount
        if (moneyMatches.length >= 3) {
          const alt = parseMoneyToPaise(moneyMatches[moneyMatches.length - 2].text);
          if (previousBalancePaise !== null && alt !== null && closingPaise !== null) {
            if (previousBalancePaise + alt === closingPaise) { determinedType = 'credit'; finalAmountPaise = alt; }
            else if (previousBalancePaise - alt === closingPaise) { determinedType = 'debit'; finalAmountPaise = alt; }
          }
        }
      }
      if (!determinedType) {
        // narration hints
        if (/payment from|credited|received|cr|payment received/i.test(narration)) determinedType = 'credit';
        else if (/withdrawal|payment to|debited|paid to|spent|dr/i.test(narration)) determinedType = 'debit';
        else if (previousBalancePaise !== null && closingPaise !== null) {
          determinedType = (closingPaise > previousBalancePaise) ? 'credit' : 'debit';
        } else {
          determinedType = 'debit';
        }
      }

      // update previous balance from closingPaise if available
      if (closingPaise !== null) previousBalancePaise = closingPaise;

      const cp = extractCounterparty(narration || '');
      // DEBUG: Print counterparty extraction for each line
      console.log(`Line ${i}:`, { narration, counterparty: cp });

      rows.push(buildRow(txnDate, valDateRaw, narration, refField, cp, determinedType, finalAmountPaise, closingPaise, raw));
    } // end loop lines
  } else {
    // fallback buffer parsing (less accurate but same logic)
    let buffer = null;
    for (let ln of lines) {
      let tln = safeTrim(ln);
      if (!tln) continue;
      if (dateStartRe.test(ln)) {
        if (buffer !== null) {
          const parsed = parseBufferLine(buffer, previousBalancePaise);
          if (parsed) {
            rows.push(parsed.row);
            if (parsed.row.balance_paise !== null) previousBalancePaise = parsed.row.balance_paise;
          }
        }
        buffer = tln;
      } else {
        if (buffer === null) continue;
        buffer += ' ' + tln;
      }
    }
    if (buffer !== null) {
      const parsed = parseBufferLine(buffer, previousBalancePaise);
      if (parsed) rows.push(parsed.row);
    }
  }

  return { rows, openingBalancePaise: openingBalancePaise };
}

/* fallback buffer parser used when header not found */
function parseBufferLine(s, prevBalancePaise) {
  s = s.replace(/\s+/g,' ');
  const moneyTokRe = /\d{1,3}(?:,\d{3})*(?:\.\d{1,2})?/g;
  const moneyTokens = Array.from(s.match(moneyTokRe) || []);
  if (moneyTokens.length === 0) return null;

  function parseMoneyToPaiseLocal(str) {
    if (!str) return null;
    const m = (''+str).match(/\d{1,3}(?:,\d{3})*(?:\.\d{1,2})?/);
    if (!m) return null;
    const cleaned = m[0].replace(/,/g,'');
    const v = parseFloat(cleaned);
    if (!isFinite(v)) return null;
    return Math.round(v * 100);
  }
  const firstMoney = moneyTokens[0];
  const lastMoney = moneyTokens[moneyTokens.length - 1];
  const candidatePaise = parseMoneyToPaiseLocal(firstMoney);
  const closingPaise = parseMoneyToPaiseLocal(lastMoney);

  const dateMatch = s.match(/^(\d{1,2}[\/-]\d{1,2}[\/-]\d{2,4})\s+(.*)$/);
  if (!dateMatch) return null;
  const dateRaw = dateMatch[1];
  let rest = dateMatch[2];

  // maybe value date inside rest
  let valueDateRaw = '';
  const vdMatch = rest.match(/(\d{1,2}\/\d{1,2}\/\d{2,4})\s+(.*)$/);
  if (vdMatch) { valueDateRaw = vdMatch[1]; rest = vdMatch[2]; }

  // narration = rest without final money token
  const lastIdx = rest.lastIndexOf(lastMoney);
  let narration = (lastIdx >= 0) ? rest.slice(0,lastIdx).trim() : rest.trim();
  const parts = narration.split(/\s{2,}/).map(s=>s.trim()).filter(Boolean);
  let ref = '';
  if (parts.length > 1) { ref = parts.slice(1).join(' '); narration = parts[0]; }

  // normalize date
  let txnDate = '';
  const md = dateRaw.match(/(\d{1,2})[\/-](\d{1,2})[\/-](\d{2,4})/);
  if (md) { let dd = md[1].padStart(2,'0'), mm = md[2].padStart(2,'0'), yy = md[3]; if (yy.length===2) yy = '20'+yy; txnDate = `${yy}-${mm}-${dd}`; }

  // decide using diff
  let determinedType = null;
  let finalAmountPaise = candidatePaise !== null ? candidatePaise : 0;
  if (prevBalancePaise !== null && closingPaise !== null && finalAmountPaise !== null) {
    if (prevBalancePaise + finalAmountPaise === closingPaise) determinedType = 'credit';
    else if (prevBalancePaise - finalAmountPaise === closingPaise) determinedType = 'debit';
  }
  if (!determinedType) {
    if (prevBalancePaise !== null && closingPaise !== null) determinedType = (closingPaise > prevBalancePaise) ? 'credit' : 'debit';
    else determinedType = /payment from|credited|received|cr/i.test(narration) ? 'credit' : 'debit';
  }
  const cp = extractCounterparty(narration);
  
  const row = {
    txn_date: txnDate,
    value_date: valueDateRaw || '',
    counterparty: cp,
    narration: narration.replace(/\s+/g,' ').trim(),
    reference: ref.trim(),
    txn_type: determinedType,
    amount_paise: finalAmountPaise !== null ? finalAmountPaise : 0,
    debit_paise: (determinedType === 'debit') ? (finalAmountPaise || 0) : 0,
    credit_paise: (determinedType === 'credit') ? (finalAmountPaise || 0) : 0,
    balance_paise: closingPaise !== null ? closingPaise : null,
    raw_line: s
  };
  return { row };
}

/* ---------- CSV builder / verification ---------- */
function buildCSVFromRows(rows, opts) {
  // opts: { nullForOtherSide: bool }
  // CSV headers: txn_date,value_date,counterparty,narration,reference,txn_type,amount_paise,debit_paise,credit_paise,balance_paise,raw_line
  const headers = ['txn_date','value_date','counterparty','narration','reference','txn_type','amount_paise','debit_paise','credit_paise','balance_paise','raw_line'];
  function needsQuote(s) {
    if (s === null || s === undefined) return false;
    const v = String(s);
    return v.includes('"') || v.includes(',') || v.includes('\n');
  }
  function escapeStr(s) {
    if (s === null || s === undefined) return '';
    const v = String(s);
    if (needsQuote(v)) return '"' + v.replace(/"/g,'""') + '"';
    return v;
  }

  const lines = [headers.join(',')];
  for (const r of rows) {
    // amount_paise, debit_paise, credit_paise, balance_paise numeric handling
    const numFields = {};
    numFields.amount_paise = (r.amount_paise !== null && r.amount_paise !== undefined) ? String(r.amount_paise) : 'NULL';
    // For non-used side decide between 0 or NULL
    if (r.debit_paise !== null && r.debit_paise !== undefined && r.debit_paise > 0) {
      numFields.debit_paise = String(r.debit_paise);
      numFields.credit_paise = opts.nullForOtherSide ? 'NULL' : '0';
    } else if (r.credit_paise !== null && r.credit_paise !== undefined && r.credit_paise > 0) {
      numFields.credit_paise = String(r.credit_paise);
      numFields.debit_paise = opts.nullForOtherSide ? 'NULL' : '0';
    } else {
      // both zero
      numFields.debit_paise = opts.nullForOtherSide ? 'NULL' : '0';
      numFields.credit_paise = opts.nullForOtherSide ? 'NULL' : '0';
    }
    numFields.balance_paise = (r.balance_paise !== null && r.balance_paise !== undefined) ? String(r.balance_paise) : 'NULL';

    // build row: for numeric fields we output literal unquoted tokens (e.g., 1234 or NULL)
    const items = [];
    items.push(escapeStr(r.txn_date || ''));
    items.push(escapeStr(r.value_date || ''));
    items.push(escapeStr(r.counterparty || ''));
    items.push(escapeStr(r.narration || ''));
    items.push(escapeStr(r.reference || ''));
    items.push(escapeStr(r.txn_type || ''));
    // amount_paise (numeric)
    items.push(numFields.amount_paise);
    items.push(numFields.debit_paise);
    items.push(numFields.credit_paise);
    items.push(numFields.balance_paise);
    items.push(escapeStr(r.raw_line || ''));
    lines.push(items.join(','));
  }
  return lines.join('\n');
}

/* ---------- Verify simulation ---------- */
function verifyRows(rows, openingBalancePaise) {
  // For each row: compute expected closing using previous balance +/- amount and compare to parsed balance_paise
  // We track previousBalance (starting from openingBalancePaise if available)
  const issues = [];
  let previous = (openingBalancePaise !== null && openingBalancePaise !== undefined) ? openingBalancePaise : null;
  for (let i=0;i<rows.length;i++) {
    const r = rows[i];
    const amount = (r.amount_paise !== null && r.amount_paise !== undefined) ? Number(r.amount_paise) : 0;
    const closing = (r.balance_paise !== null && r.balance_paise !== undefined) ? Number(r.balance_paise) : null;
    let expectedAdd = null;
    let expectedSub = null;
    if (previous !== null) {
      expectedAdd = previous + amount;
      expectedSub = previous - amount;
    }
    let match = null;
    if (previous !== null && closing !== null) {
      if (expectedAdd === closing) match = 'credit (previous + amount == closing)';
      else if (expectedSub === closing) match = 'debit (previous - amount == closing)';
      else match = 'mismatch';
    } else {
      match = 'no-previous-or-closing';
    }

    const ok = (match !== 'mismatch');
    if (!ok) {
      // provide diagnostic: show previous, amount, expectedAdd, expectedSub, actual
      issues.push({
        row_index: i,
        txn_date: r.txn_date,
        narration: r.narration,
        previous_balance_paise: previous,
        amount_paise: amount,
        expected_add: expectedAdd,
        expected_sub: expectedSub,
        parsed_closing_paise: closing,
        note: 'balance-diff mismatch'
      });
    }
    // update previous to parsed closing when available (best guess)
    if (closing !== null) previous = closing;
    else previous = previous; // unchanged
  }
  return { issues, ok: issues.length === 0, openingBalancePaise: openingBalancePaise };
}

/* ---------- UI wiring ---------- */
document.getElementById('file').addEventListener('change', async (ev) => {
  const f = ev.target.files[0];
  if (!f) return;
  if (!f.name.toLowerCase().endsWith('.txt')) {
    if (!confirm('File does not have .txt extension. Try parse anyway?')) return;
  }
  const txt = await f.text();
  document.getElementById('inputText').value = txt;
});

document.getElementById('loadSample').addEventListener('click', ()=> {
  const sample = `--------  ----------------------------------------  ----------------  --------  ------------------  ------------------  ------------------
Date      Narration                    Chq./Ref.No.      Value Dt  Withdrawal Amt.        Deposit Amt.     Closing Balance
--------  ----------------------------------------  ----------------  --------  ------------------  ------------------  ------------------

01/09/25  UPI-VEDANT DEVENDRA PADH-VEDANTPADHIYAR1  0000561034216912  01/09/25                                100.00              103.33   
          78@OKICICI-UBIN0566934-561034216912-UPI
01/09/25  UPI-ISHWAR FUELS-Q501479440@YBL-YESB0YBL  0000110607405658  01/09/25             100.00                                   3.33   
          UPI-110607405658-UPI
01/09/25  UPI-VIDYASAGAR CHAUDHARI-9770472492@AXIS  0000229168912445  01/09/25                                200.00              203.33   
          BANK-UTIB0000587-229168912445-UPI
`;
  document.getElementById('inputText').value = sample;
});

document.getElementById('convert').addEventListener('click', async () => {
  const text = document.getElementById('inputText').value;
  if (!text || !text.trim()) { alert('Paste or upload .txt'); return; }
  document.getElementById('status').textContent = 'Parsing...';
  try {
    const { rows, openingBalancePaise } = parseStatementToRows(text);
    const nullForOtherSide = document.getElementById('optNullSide').checked;
    const csv = buildCSVFromRows(rows, { nullForOtherSide });
    // trigger download
    const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
    const url = URL.createObjectURL(blob);
    const a = document.getElementById('downloadLink');
    a.href = url;
    a.download = 'statement_parsed_paise.csv';
    a.style.display = 'inline-block';
    a.textContent = 'Download CSV';
    // show preview
    document.getElementById('preview').textContent = rows.slice(0,10).map((r,idx)=> `${idx+1}. ${r.txn_date} | ${r.counterparty} | ${r.txn_type} | amt_paise:${r.amount_paise} | debit:${r.debit_paise} credit:${r.credit_paise} | bal:${r.balance_paise} | ${r.narration}`).join('\n') || '(no rows)';
    document.getElementById('status').textContent = `Converted ${rows.length} rows. Opening balance (paise): ${openingBalancePaise === null ? '(not found)' : openingBalancePaise}`;
    // verify optionally
    if (document.getElementById('optVerify').checked) {
      const report = verifyRows(rows, openingBalancePaise);
      renderVerifyReport(report);
      // also enable download
      const rblob = new Blob([JSON.stringify(report, null, 2)], {type:'application/json'});
      const rurl = URL.createObjectURL(rblob);
      const ra = document.getElementById('downloadReport');
      ra.href = rurl;
      ra.download = 'verify_report.json';
      ra.style.display = 'inline-block';
      ra.textContent = 'Download Verify Report (JSON)';
    } else {
      document.getElementById('downloadReport').style.display = 'none';
      document.getElementById('verifyReport').textContent = '(verify not run)';
    }
  } catch (err) {
    console.error(err);
    document.getElementById('status').textContent = 'Parse error: ' + (err && err.message ? err.message : String(err));
  }
});

document.getElementById('runVerify').addEventListener('click', () => {
  const text = document.getElementById('inputText').value;
  if (!text || !text.trim()) { alert('Paste or upload .txt first'); return; }
  document.getElementById('status').textContent = 'Parsing for verify...';
  try {
    const { rows, openingBalancePaise } = parseStatementToRows(text);
    const report = verifyRows(rows, openingBalancePaise);
    renderVerifyReport(report);
    const rblob = new Blob([JSON.stringify(report, null, 2)], {type:'application/json'});
    const rurl = URL.createObjectURL(rblob);
    const ra = document.getElementById('downloadReport');
    ra.href = rurl;
    ra.download = 'verify_report.json';
    ra.style.display = 'inline-block';
    ra.textContent = 'Download Verify Report (JSON)';
    document.getElementById('status').textContent = `Verify finished. Issues: ${report.issues.length}`;
  } catch (err) {
    console.error(err);
    document.getElementById('status').textContent = 'Verify error: ' + (err && err.message ? err.message : String(err));
  }
});

function renderVerifyReport(report) {
  const lines = [];
  lines.push('Verify run');
  lines.push('Opening balance (paise): ' + (report.openingBalancePaise === null ? '(not found)' : report.openingBalancePaise));
  lines.push('Summary: ' + (report.ok ? 'OK — no mismatches' : `MISMATCHES: ${report.issues.length}`));
  lines.push('');
  if (report.issues.length === 0) {
    lines.push('(no issues found)');
  } else {
    lines.push('Issues (first 50):');
    for (let i=0;i<Math.min(report.issues.length,50);i++) {
      const it = report.issues[i];
      lines.push(`Row ${it.row_index}: date=${it.txn_date} narration="${it.narration}"`);
      lines.push(`  previous=${it.previous_balance_paise} amount=${it.amount_paise} expectedAdd=${it.expected_add} expectedSub=${it.expected_sub} parsedClosing=${it.parsed_closing_paise}`);
      lines.push(`  note: ${it.note}`);
    }
  }
  document.getElementById('verifyReport').textContent = lines.join('\n');
}

// convenience: parseStatementToRows must be exposed to parseBufferLine fallback usage above
// (we defined parseBufferLine as a nested helper earlier in the long initial design — for brevity we included a local fallback implementation above)

/* End of script */
</script>
</body>
</html>
